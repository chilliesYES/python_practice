from pathlib import Path
import time
from datetime import datetime
import os
import shutil
from tkinter import *
from tkinter import messagebox


# test:D:\ev录屏\EVCapture

class filebody:
    name = None
    size = None
    location = None
    mtime = None
    signer = None

    def __init__(self, name, size, location, mtime, signer=None):
        self.name = name
        self.size = size
        self.location = location
        self.mtime = time.strftime("%Y年%m月%d日 %H:%M:%S", time.localtime(mtime))
        self.signer = signer
    # self.mtime=time.ctime(mtime)


class filema:
    mesize = 0
    tank = []
    tankfolder = []
    tankfile = []

    def __init__(self, fapath):
        self.fapath = fapath

    # def getsigner(self,file_path):
    # 	try:
    # 		# 使用 win32api 获取文件签名信息
    # 		signed_info = win32api.VerifyVersionInfo(self.file_path, None)
    # 		cert = win32crypt.CryptQueryObject(signed_info, self.file_path, None, None, None)
    #
    # 		# 从证书中提取签名者信息（一般包括名字）
    # 		signer_info = cert['SignerInfo']
    # 		signer_name = signer_info['Name']
    #
    # 		return signer_name
    # 	except Exception:
    # 		pass
    def shallowstore(self, path):
        for each in path.iterdir():
            try:
                filestat = each.stat()
                name = each.name
                size = filestat.st_size / (1024 * 1024)
                location = each.resolve()
                mtime = filestat.st_mtime
                self.tank.append(filebody(name, size, location, mtime))
                if each.is_file():
                    # signer = self.getsigner(each)
                    self.tankfile.append(filebody(name, size, location, mtime))
                else:
                    size = self.foldersize(each)
                    self.tankfolder.append(filebody(name, size, location, mtime))
            except PermissionError:
                pass

    def foldersize(self, path):
        size = 0
        for i in path.iterdir():
            if i.is_file():
                size += i.stat().st_size / (1024 * 1024)
            else:
                k = self.foldersize(i)
                size += k
        return size

    def store(self, path):
        self.mesize = 0
        self.tank = []
        self.tankfolder = []
        self.tankfile = []
        def sss(path):
            for each in path.iterdir():
                try:
                    filestat = each.stat()
                    name = each.name
                    size = filestat.st_size / (1024 * 1024)
                    location = each.resolve()
                    mtime = filestat.st_mtime
                    self.tank.append(filebody(name, size, location, mtime))
                    if each.is_file():
                        self.tankfile.append(filebody(name, size, location, mtime))
                    else:
                        size = self.foldersize(each)
                        self.tankfolder.append(filebody(name, size, location, mtime))
                        sss(each)
                except PermissionError:
                    pass
        sss(path)

    def newfilestore(self, path):
        filestat = path.stat()
        name = path.name
        size = filestat.st_size / (1024 * 1024)
        location = path.resolve()
        mtime = filestat.st_mtime
        self.tank.append(filebody(name, size, location, mtime))
        if path.is_dir():
            size = self.foldersize(path)
            self.tankfolder.append(filebody(name, size, location, mtime))
        else:
            self.tankfile.append(filebody(name, size, location, mtime))

    def show(self, space):  # 1all 2folder 3file
        if space == 1:
            for i in self.tank:
                print(i.location)
        elif space == 2:
            for i in self.tankfolder:
                print(i.location)
        elif space == 3:
            for i in self.tankfile:
                print(i.location)
        else:
            print('show函数参数错误')
            pass

    def sefile(self,ufile):
        outpack=str()
        if ufile[0] == '.':
            for i in self.tankfile:
                if i.location.suffix == ufile:
                    outpack += f'{i.name}\n大小:{i.size:.3f}M \n地址:{i.location} \n上次修改时间:{i.mtime}\n\n'
        else:
            for i in self.tank:
                if ufile in i.name:
                    outpack += f'{i.name}\n大小:{i.size:.3f}M \n地址:{i.location} \n上次修改时间:{i.mtime}\n\n'
        return outpack


from tkinter.filedialog import *


def load(path, mode):
    global fapath
    global f
    def pp(path, mode):
        global fapath
        global f
        fapath = Path(path)
        f = filema(fapath)
        if mode == 1:
            a.infowindow('深层模式加载中。。。。。。')
            f.store(fapath)
            #print(f.tankfile)
            a.infowindow('深层模式加载完成')
        elif mode == 0:
            a.infowindow('浅层模式加载中。。。。。。')
            f.shallowstore(fapath)
            a.infowindow('浅层模式加载完成')
    if path == '':
        cpath = askdirectory()
        pp(cpath, mode)
    else:
        pp(path, mode)

def sofile():
    global fapath
    global f
    #print('ssss')
    _ = sorted(f.tankfile, key=lambda item: item.size, reverse=True)
    n = 1
    out=str()
    for each in _[0:a.r1e1.get()]:#获取1行公共enter的值
        out += f'{n:<3} {each.name:<30}{each.size:>8.2f}M\n'
        print(each.name)
        n = n + 1
    a.infowindow(out)
def sodir():
    global fapath
    global f
    _ = sorted(f.tankfolder, key=lambda item: item.size, reverse=True)  # 排序对象的一个对象列表key要这样传递
    n = 1
    out=str()
    for each in _[0:a.r1e1.get()]:
        out += f'{n:<3} {each.name:<30}{each.size:>.2f}M\n'
        n += 1
    a.infowindow(out)

def newf():
    global fapath
    global f
    m = a.modec1.get()
    if m == 0:
        try:
            newfn = a.newname.get()
            (fapath / newfn).touch(exist_ok=False)
            f.newfilestore(fapath / newfn)
            a.infowindow(f'{newfn}创建完成')
        except FileExistsError:
            a.infowindow('你想创建的文件已经存在')
    elif m == 1:
        newfn = a.newname.get()
        num = a.r2e2.get()
        for i in range(num):
            order = str(i + 1) + '_'
            path = fapath / (order + newfn)
            path.touch()
            f.newfilestore(path)
        a.infowindow(f'{num}个{newfn}创建完成')
def newd():
    global fapath
    global f
    m = a.modec1.get()
    if m == 0:
        try:
            newfn = a.newname.get()
            (fapath / newfn).mkdir(exist_ok=False)
            f.newfilestore(fapath / newfn)
            a.infowindow(f'{newfn}创建完成')
        except FileExistsError:
            a.infowindow('你想创建的文件夹已经存在')
    elif m == 1:
        newfn = a.newname.get()
        num = a.r2e2.get()
        for i in range(num):
            order = str(i + 1) + '_'
            path = fapath / (order + newfn)
            path.mkdir()
            f.newfilestore(path)
        a.infowindow(f'{num}个{newfn}创建完成')
def sefile():
    global fapath
    global f
    _=f.sefile(a.insefile.get())
    a.infowindow(_)
def seexpname():
    global fapath
    global f
    exname = set()
    for each in f.tankfile:
        _ = each.location
        #print(_.suffix)
        exname.add(_.suffix)
    exname=(' '.join(exname))
    a.infowindow(exname)
def tree(path, i=1):
    treetank=str()
    def _ff(path,i=1):
        nonlocal treetank
        for each in path.iterdir():
            try:
                _bb = ' -' * i
                treetank += f'{_bb} {each.name}\n'
                if each.is_dir():
                    _ff(each, i + 1)#可能有问题
            except PermissionError:
                pass
    _ff(path, i)
    a.infowindow(treetank)

def delempty():
    global fapath
    global f
    out=str()
    for each in f.tankfolder:
        if each.size == 0:
            try:
                each.location.rmdir()
                out += each.name+'  PATH:'+each.location+'\n'
                (f.tankfolder).pop(each)
                (f.tank).pop(each)
            except:
                a.infowindow(out)
                print('delempty报错')
    a.infowindow(out)



class app(Frame):
    def __init__(self, master=None):
        super().__init__(master)
        self.grid(column=0, row=0, columnspan=2)
        self.master = master
        self.up()
        self.infowindow()
        self.filecrt()
        self.dircrt()
        self.publicen()
    def tt(self):
        messagebox.showinfo("test", "test")
    def saveinfo(self):
        s = asksaveasfilename(defaultextension='.txt', filetypes=[("Text files", "*.txt"), ("All files", "*.*")])
        with open(s, 'w') as ss:
            ss.writelines(self.info)
            self.addinfo(f'{Path(s).name}成功保存到  {s}')


    def up(self):
        self.enpath = StringVar()
        modc = IntVar()
        p1 = Entry(self, textvariable=self.enpath);p1.grid(row=0, column=0, columnspan=3, sticky=EW, ipady=5, padx=5, pady=20)
        _=Button(self, text='   加载   ');_.grid(row=0, column=3, sticky=W,padx=5);_.bind('<Button-1>', lambda event: load(self.enpath.get(), modc.get()))
        Checkbutton(self, text='深层模式', variable=modc, onvalue=1, offvalue=0).grid(row=0, column=3, sticky=E)

        self.window = Text(self.master, width=1, height=10)
        self.window.grid(row=1, column=0, padx=5, pady=10, columnspan=2, sticky=EW)
        bar = Scrollbar(self.master, command=self.window.yview)
        self.window.config(yscrollcommand=bar.set)
        bar.grid(row=1, column=2, pady=10,sticky=NS)
        Button(self.master, text='        退出       ', command=root.destroy).grid(row=2, column=0)
        Button(self.master, text='     导出为txt      ', command=self.saveinfo).grid(row=2, column=1)
    def infowindow(self, info=None):
        self.window.delete(1.0, END)
        self.info = str(info)
        self.window.insert(1.0, self.info)
    def addinfo(self, info=None):
        self.ainfo='\n'+str(info)
        self.window.insert(END, self.ainfo)


    def publicen(self):
        self.r1e1 = IntVar()
        self.r2e1 = StringVar()
        self.r2e2 = IntVar()
        self.modec1 = IntVar()
        self.newname = StringVar()
        global fapath
        global f
        Entry(self, textvariable=self.r1e1, width=5).grid(row=1, column=3, sticky=W)
        Entry(self, textvariable=self.newname, width=10).grid(row=2, column=3, sticky=W)
        Label(self, text='期望排序个数:').grid(row=1, column=2)
        Label(self, text='名    称:').grid(row=2, column=2)
        Checkbutton(self, text='批量创建', variable=self.modec1, onvalue=1, offvalue=0).grid(row=2, column=3, sticky=E)#modc1已改
        Entry(self, textvariable=self.r2e2, width=2).grid(row=2, column=4, sticky=W)
        _tree = Button(self, text='展示目录树', command=lambda :tree(fapath));_tree.grid(row=4, column=0,columnspan=2, padx=5,sticky=EW)
        self.treetank=str();_tree.bind('<Button-1>', self.infowindow(self.treetank))
        Button(self, text='清除所有空文件夹', command=delempty).grid(row=4, column=2, columnspan=3, padx=5, sticky=EW)


    def filecrt(self):
        #modc2=IntVar()
        self.expn = StringVar()
        self.insefile = StringVar()
        Button(self, text='按文件大小排序', command=sofile).grid(row=1, column=0, padx=5)
        Button(self, text='创建新的文件',command=newf).grid(row=2, column=0, padx=5, sticky=EW)
        Button(self, text='搜索文件', command=sefile).grid(row=3, column=0, padx=5, sticky=EW)
        Entry(self, textvariable=self.insefile).grid(row=3, column=1, padx=5, sticky=W)#这里有个公共entry懒得改了
        Button(self, text='获取所有后缀', command=seexpname).grid(row=3, column=2, padx=5,sticky=EW)
        Entry(self, textvariable=self.expn).grid(row=3, column=3, sticky=W)

    def dircrt(self):
        Button(self, text='按文件夹大小排序',command=sodir).grid(row=1, column=1,pady=5, padx=5, sticky=EW)
        Button(self, text='创建新的文件夹', command=newd).grid(row=2, column=1, padx=5, sticky=EW)

if __name__ == '__main__':
    root=Tk()
    root.geometry('530x400')
    a=app(root)
    a.mainloop()

